/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "communicate.h"
#include <stdio.h>
#include <stdlib.h>
#include <dirent.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>
#include <pthread.h>

//global nodelist 

//------------------------------- CLIENT CREATE -------------------------------
CLIENT *setup_connection(char *con_server_ip, char *con_server_port) {
	//printf("creating connection with ip %s, port %s\n", con_server_ip, con_server_port);

	// create this servers socket 
	// note, this server acts as a client to other servers
	// and has client connection "objects" for them
	int sockfd;
	if ( (sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0 ) {
		perror("socket creation failed");
		return NULL;
	}
	
	// fill in information about the given server
	struct sockaddr_in servaddr;
	memset(&servaddr, 0, sizeof(servaddr));
	   
	servaddr.sin_family = AF_INET;
	int server_port_int = atoi(con_server_port);
	servaddr.sin_port = htons(server_port_int);

	//fill in the IP address as it's binary representation
	if (inet_pton(AF_INET, con_server_ip, &servaddr.sin_addr) <= 0) {
		printf("Invalid IP address\n");
		close(sockfd);
		return NULL;
	}

	//setup the timeout for rpc calls
	struct timeval wait;
	memset(&wait, 0, sizeof(wait));
	wait.tv_sec = 2;

	// create the object
	CLIENT *clnt = clntudp_create (&servaddr, COMMUNICATE_PROG, COMMUNICATE_VERSION, wait, &sockfd);
	if (clnt == NULL) {
		clnt_pcreateerror (con_server_ip);
		return NULL;
	}

	return clnt;
}



// ------------------------------ SERVER RPC SETUP ------------------------------
static struct timeval TIMEOUT = { 25, 0 };
NodeList *
find_1(char *filename,  CLIENT *clnt)
{
	static NodeList clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, Find,
		(xdrproc_t) xdr_char, (caddr_t) &filename,
		(xdrproc_t) xdr_NodeList, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
download_1(char *filename,  CLIENT *clnt)
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, Download,
		(xdrproc_t) xdr_char, (caddr_t) &filename,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}
// ------------------------------ END SERVER RPC SETUP ------------------------------

typedef struct send_thread_args{
	int sockfd;
	char *filename;
} send_thread_args;
typedef struct download_thread_args{
	int sender_port;
	char *sender_ip;
	char *filename;
} download_thread_args;

int load = 0;
char this_peer_dir[] = {"tempname"};
FileList filelist;
// global char[120] server_type

void scan(char *dir){
	struct dirent *pDirent;
    DIR *pDir;

    pDir = opendir(this_peer_dir);
    if(pDir == NULL){
        printf("Cannot open directory %s.\n", this_peer_dir);
        return;
    }

    printf("Opened directory %s.\n", this_peer_dir);

    struct stat sb;

    int i = 0;
    while((pDirent = readdir(pDir)) != NULL){
        if(strcmp(pDirent->d_name, "..") != 0 && strcmp(pDirent->d_name, ".") != 0){
            //printf("[%s]\n", pDirent->d_name);
            file thisFile;
            strcpy(thisFile.name, pDirent->d_name);
            char filePath[256];
            strcpy(filePath, this_peer_dir);
            strcat(filePath, "/");
            strcat(filePath, pDirent->d_name);

            if(stat(filePath, &sb) == -1){
                perror("stat");
            }
            else{
                thisFile.size = (int) sb.st_size;
                filelist.files[i] = thisFile;
                i++;
            }
			if(i == 50) break;
        }
    }
	filelist.fileAmount = i;

    closedir(pDir);

    for(int j = 0; j < filelist.fileAmount; j++){
        printf("File: %s of size %d bytes.\n", filelist.files[j].name, filelist.files[j].size);
    }
    
    return;
}

void* download_thread(void *arg){
	int *sockfd = (int *) arg;
	load++; //MIGHT NEED TO LOCK THIS
	int client_socket;
	ssize_t len;
	struct sockaddr_in remote_addr;
	char buffer[BUFSIZ];
	int file_size;
	FILE *received_file;
	int remain_data = 0;

	download_thread_args *args = (download_thread_args *) arg;

	/* Zeroing remote_addr struct */
	memset(&remote_addr, 0, sizeof(remote_addr));

	/* Construct remote_addr struct */
	remote_addr.sin_family = AF_INET;
	inet_pton(AF_INET, args->sender_ip, &(remote_addr.sin_addr));
	remote_addr.sin_port = htons(args->sender_port);

	/* Create client socket */
	client_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (client_socket == -1)
	{
		fprintf(stderr, "Error creating socket");
		exit(EXIT_FAILURE);
	}

	/* Connect to the server */
	if (connect(client_socket, (struct sockaddr *)&remote_addr, sizeof(struct sockaddr)) == -1)
	{
			fprintf(stderr, "Error on connect");

			exit(EXIT_FAILURE);
	}

	/* Receiving file size */
	recv(client_socket, buffer, BUFSIZ, 0);
	file_size = atoi(buffer);
	//fprintf(stdout, "\nFile size : %d\n", file_size);

	received_file = fopen(args->filename, "w");
	if (received_file == NULL)
	{
		fprintf(stderr, "Failed to open file foo");
		exit(EXIT_FAILURE);
	}

	remain_data = file_size;

	while ((remain_data > 0) && ((len = recv(client_socket, buffer, BUFSIZ, 0)) > 0))
	{
			fwrite(buffer, sizeof(char), len, received_file);
			remain_data -= len;
			fprintf(stdout, "Receive %d bytes and we hope :- %d bytes\n", len, remain_data);
	}
	fclose(received_file);

	close(client_socket);

	return 0; //test
}

void* send_thread(void* arg){
	/* Listening to incoming connections */
	int server_socket, peer_socket, fd;
	struct sockaddr_in server_addr, peer_addr;
	socklen_t sock_len;
	int sent_bytes = 0;
	char file_size[256];
	ssize_t len;
	int remain_data;
	struct stat file_stat;
	int offset;
	char *filename_token;
	load++;

	send_thread_args *args = (send_thread_args *) arg;
	server_socket = args->sockfd;
	filename_token = args->filename;

	if ((listen(server_socket, 5)) == -1)
        {
                fprintf(stderr, "Error on listen");

                exit(EXIT_FAILURE);
        }

        fd = open(filename_token, O_RDONLY);
        if (fd == -1)
        {
                fprintf(stderr, "Error opening file");

                exit(EXIT_FAILURE);
        }

        /* Get file stats */
        if (fstat(fd, &file_stat) < 0)
        {
                fprintf(stderr, "Error fstat");

                exit(EXIT_FAILURE);
        }

        fprintf(stdout, "File Size: \n%d bytes\n", file_stat.st_size);

        sock_len = sizeof(struct sockaddr_in);
        /* Accepting incoming peers */
        peer_socket = accept(server_socket, (struct sockaddr *)&peer_addr, &sock_len);
        if (peer_socket == -1)
        {
                fprintf(stderr, "Error on accept");

                exit(EXIT_FAILURE);
        }
        fprintf(stdout, "Accept peer --> %s\n", inet_ntoa(peer_addr.sin_addr));

        sprintf(file_size, "%d", file_stat.st_size);

        /* Sending file size */
        len = send(peer_socket, file_size, sizeof(file_size), 0);
        if (len < 0)
        {
              fprintf(stderr, "Error on sending greetings" );

              exit(EXIT_FAILURE);
        }

        fprintf(stdout, "Server sent %d bytes for the size\n", len);

        offset = 0;
        remain_data = file_stat.st_size;
        /* Sending file data */
        while (((sent_bytes = sendfile(peer_socket, fd, &offset, BUFSIZ)) > 0) && (remain_data > 0))
        {
                fprintf(stdout, "1. Server sent %d bytes from file's data, offset is now : %d and remaining data = %d\n", sent_bytes, offset, remain_data);
                remain_data -= sent_bytes;
                fprintf(stdout, "2. Server sent %d bytes from file's data, offset is now : %d and remaining data = %d\n", sent_bytes, offset, remain_data);
        }

        close(peer_socket);
        close(server_socket);
		pthread_exit(NULL);

}

Node* peer_select(NodeList *list){
	// select a peer from the list based on load and latency
	// return the peer
}

// void read_config(){
	//hardcoded file name/path
// }


NodeList *
find_1_svc(char *filename,  struct svc_req *rqstp)
{
	static NodeList  result;

	/*
	 * insert server code here
	 */
	//if server_type == trackingserver

	// only called by peers to trackingserver
	// return list of peers that have the file
	// for loop updatelist across all peers
	// 		update the global node list
	// return list of peers that have the file

	return &result;
}

int *
download_1_svc(char *filename,  struct svc_req *rqstp)
{
	static int  result;

	/*
	 * insert server code here
	 */

	//after download, call scan
	//split file name by space if there is a space

	char* send_token = strtok(filename, " ");
	if (strcmp(send_token, "send") == 0){
		NodeList find_list = find_1(filename, trackingserver);
		if(find_list == NULL){
			printf("Error: find_1 returned NULL.\n");
			return -1;
		}
		Node* peer = peer_select(&find_list);


		if (peer== NULL){
			printf("Error: peer_select returned NULL.\n");
			return -1;
		}
		//setup connection to peer
		CLIENT *clnt = setup_client(peer->ip, peer->port);
		if(clnt == NULL){
			printf("Error: setup_client returned NULL.\n");
			return -1;
		}

		//call download on peer
		// add "send filename" to download_1 to indicate to send a file

		int download_result = download_1(filename, clnt);
		if(download_result == NULL){
			printf("Error: download_1 returned NULL.\n");
			return -1;
		}
		pthread_t thread;
		download_thread_args *args = (download_thread_args *) malloc(sizeof(download_thread_args));
		args->sender_port = download_result;
		args->sender_ip = peer->ip;
		args->filename = filename;
		pthread_create(&thread, NULL, &download_thread, (void *) args); //this arguement should be the port number to download from
	
	}
	else if (strcmp(send_token, "send") != 0){
		char* filename_token = strtok(NULL, " ");
		if (filename_token == NULL){
			printf("Error: strtok returned NULL.\n");
			return -1;
		}
		//start sending a file on a port
		
		//set up port
		int server_socket;
        socklen_t       sock_len;
        struct sockaddr_in      server_addr;

        /* Create server socket */
        server_socket = socket(AF_INET, SOCK_STREAM, 0);
        if (server_socket == -1)
        {
			fprintf(stderr, "Error creating socket" );
			exit(EXIT_FAILURE);
        }

        /* Zeroing server_addr struct */
        memset(&server_addr, 0, sizeof(server_addr));
        /* Construct server_addr struct */
        server_addr.sin_family = AF_INET;
        inet_pton(AF_INET, "127.0.0.1", &(server_addr.sin_addr));
        server_addr.sin_port = htons(0);

        /* Bind */
        if ((bind(server_socket, (struct sockaddr *)&server_addr, sizeof(struct sockaddr))) == -1)
        {
                fprintf(stderr, "Error on bind");
                exit(EXIT_FAILURE);
        }

		pthread_t thread;
		send_thread_args *args = malloc(sizeof(send_thread_args));
		args->filename = filename_token;
		args->sockfd = server_addr.sin_port;
		printf("args->sockfd: %d\n", args->sockfd);
		printf("args->filename: %s\n", args->filename);

		pthread_create(&thread, NULL, &send_thread, (void *)args); 
        
		result = args->sockfd;
        return &result;


	}

	//download file from peer
	//choose a peer from the list based on load and latency

	// if found
	// load++;
	// spawn a thread to download the file

	//else
	// return -1

	return &result;
}

int *
getload_1_svc(struct svc_req *rqstp)
{
	static int  result;

	/*
	 * insert server code here
	 */

	// lock the load variable
	// read it 
	// unlock it
	// return it


	return &result;
}

FileList *
updatelist_1_svc(struct svc_req *rqstp)
{
	static FileList  result;

	/*
	 * insert server code here
	 */
	//scan directory for files

	return &result;
}
